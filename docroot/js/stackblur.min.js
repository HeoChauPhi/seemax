var StackBlur = (function () {
  const t = [
      512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292,
      512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292,
      273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259,
      496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292,
      282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373,
      364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259,
      507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381,
      374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292,
      287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461,
      454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373,
      368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309,
      305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259,
      257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442,
      437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381,
      377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332,
      329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292,
      289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259,
    ],
    e = [
      9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17,
      17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19,
      19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
      20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
      21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22,
      22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
      22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
      23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
      23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
      23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
      24, 24,
    ];
  function n(t, e, n, r, o) {
    if (
      ("string" == typeof t && (t = document.getElementById(t)),
      !(t && "object" == typeof t && "getContext" in t))
    )
      throw new TypeError(
        "Expecting canvas with `getContext` method in processCanvasRGB(A) calls!"
      );
    const a = t.getContext("2d");
    try {
      return a.getImageData(e, n, r, o);
    } catch (t) {
      throw new Error("unable to access image data: " + t);
    }
  }
  function r(t, e, r, a, l, g) {
    if (isNaN(g) || g < 1) return;
    g |= 0;
    let i = n(t, e, r, a, l);
    (i = o(i, e, r, a, l, g)), t.getContext("2d").putImageData(i, e, r);
  }
  function o(n, r, o, a, l, i) {
    const c = n.data,
      s = 2 * i + 1,
      f = a - 1,
      u = l - 1,
      x = i + 1,
      b = (x * (x + 1)) / 2,
      h = new g();
    let d,
      m = h;
    for (let t = 1; t < s; t++) (m = m.next = new g()), t === x && (d = m);
    m.next = h;
    let w = null,
      p = null,
      y = 0,
      B = 0;
    const C = t[i],
      I = e[i];
    for (let t = 0; t < l; t++) {
      m = h;
      const t = c[B],
        e = c[B + 1],
        n = c[B + 2],
        r = c[B + 3];
      for (let o = 0; o < x; o++)
        (m.r = t), (m.g = e), (m.b = n), (m.a = r), (m = m.next);
      let o = 0,
        l = 0,
        g = 0,
        s = 0,
        u = x * t,
        E = x * e,
        N = x * n,
        R = x * r,
        v = b * t,
        D = b * e,
        G = b * n,
        A = b * r;
      for (let t = 1; t < x; t++) {
        const e = B + ((f < t ? f : t) << 2),
          n = c[e],
          r = c[e + 1],
          a = c[e + 2],
          i = c[e + 3],
          u = x - t;
        (v += (m.r = n) * u),
          (D += (m.g = r) * u),
          (G += (m.b = a) * u),
          (A += (m.a = i) * u),
          (o += n),
          (l += r),
          (g += a),
          (s += i),
          (m = m.next);
      }
      (w = h), (p = d);
      for (let t = 0; t < a; t++) {
        const e = (A * C) >> I;
        if (((c[B + 3] = e), 0 !== e)) {
          const t = 255 / e;
          (c[B] = ((v * C) >> I) * t),
            (c[B + 1] = ((D * C) >> I) * t),
            (c[B + 2] = ((G * C) >> I) * t);
        } else c[B] = c[B + 1] = c[B + 2] = 0;
        (v -= u),
          (D -= E),
          (G -= N),
          (A -= R),
          (u -= w.r),
          (E -= w.g),
          (N -= w.b),
          (R -= w.a);
        let n = t + i + 1;
        (n = (y + (n < f ? n : f)) << 2),
          (o += w.r = c[n]),
          (l += w.g = c[n + 1]),
          (g += w.b = c[n + 2]),
          (s += w.a = c[n + 3]),
          (v += o),
          (D += l),
          (G += g),
          (A += s),
          (w = w.next);
        const { r: r, g: a, b: x, a: b } = p;
        (u += r),
          (E += a),
          (N += x),
          (R += b),
          (o -= r),
          (l -= a),
          (g -= x),
          (s -= b),
          (p = p.next),
          (B += 4);
      }
      y += a;
    }
    for (let t = 0; t < a; t++) {
      let e = c[(B = t << 2)],
        n = c[B + 1],
        r = c[B + 2],
        o = c[B + 3],
        g = x * e,
        s = x * n,
        f = x * r,
        y = x * o,
        E = b * e,
        N = b * n,
        R = b * r,
        v = b * o;
      m = h;
      for (let t = 0; t < x; t++)
        (m.r = e), (m.g = n), (m.b = r), (m.a = o), (m = m.next);
      let D = a,
        G = 0,
        A = 0,
        W = 0,
        H = 0;
      for (let l = 1; l <= i; l++) {
        B = (D + t) << 2;
        const g = x - l;
        (E += (m.r = e = c[B]) * g),
          (N += (m.g = n = c[B + 1]) * g),
          (R += (m.b = r = c[B + 2]) * g),
          (v += (m.a = o = c[B + 3]) * g),
          (H += e),
          (G += n),
          (A += r),
          (W += o),
          (m = m.next),
          l < u && (D += a);
      }
      (B = t), (w = h), (p = d);
      for (let i = 0; i < l; i++) {
        let l = B << 2;
        (c[l + 3] = o = (v * C) >> I),
          o > 0
            ? ((o = 255 / o),
              (c[l] = ((E * C) >> I) * o),
              (c[l + 1] = ((N * C) >> I) * o),
              (c[l + 2] = ((R * C) >> I) * o))
            : (c[l] = c[l + 1] = c[l + 2] = 0),
          (E -= g),
          (N -= s),
          (R -= f),
          (v -= y),
          (g -= w.r),
          (s -= w.g),
          (f -= w.b),
          (y -= w.a),
          (l = (t + ((l = i + x) < u ? l : u) * a) << 2),
          (E += H += w.r = c[l]),
          (N += G += w.g = c[l + 1]),
          (R += A += w.b = c[l + 2]),
          (v += W += w.a = c[l + 3]),
          (w = w.next),
          (g += e = p.r),
          (s += n = p.g),
          (f += r = p.b),
          (y += o = p.a),
          (H -= e),
          (G -= n),
          (A -= r),
          (W -= o),
          (p = p.next),
          (B += a);
      }
    }
    return n;
  }
  function a(t, e, r, o, a, g) {
    if (isNaN(g) || g < 1) return;
    g |= 0;
    let i = n(t, e, r, o, a);
    (i = l(i, e, r, o, a, g)), t.getContext("2d").putImageData(i, e, r);
  }
  function l(n, r, o, a, l, i) {
    const c = n.data,
      s = 2 * i + 1,
      f = a - 1,
      u = l - 1,
      x = i + 1,
      b = (x * (x + 1)) / 2,
      h = new g();
    let d,
      m = h;
    for (let t = 1; t < s; t++) (m = m.next = new g()), t === x && (d = m);
    m.next = h;
    let w = null,
      p = null;
    const y = t[i],
      B = e[i];
    let C,
      I,
      E = 0,
      N = 0;
    for (let t = 0; t < l; t++) {
      let t = c[N],
        e = c[N + 1],
        n = c[N + 2],
        r = x * t,
        o = x * e,
        l = x * n,
        g = b * t,
        s = b * e,
        u = b * n;
      m = h;
      for (let r = 0; r < x; r++) (m.r = t), (m.g = e), (m.b = n), (m = m.next);
      let R = 0,
        v = 0,
        D = 0;
      for (let r = 1; r < x; r++)
        (C = N + ((f < r ? f : r) << 2)),
          (g += (m.r = t = c[C]) * (I = x - r)),
          (s += (m.g = e = c[C + 1]) * I),
          (u += (m.b = n = c[C + 2]) * I),
          (R += t),
          (v += e),
          (D += n),
          (m = m.next);
      (w = h), (p = d);
      for (let x = 0; x < a; x++)
        (c[N] = (g * y) >> B),
          (c[N + 1] = (s * y) >> B),
          (c[N + 2] = (u * y) >> B),
          (g -= r),
          (s -= o),
          (u -= l),
          (r -= w.r),
          (o -= w.g),
          (l -= w.b),
          (C = (E + ((C = x + i + 1) < f ? C : f)) << 2),
          (R += w.r = c[C]),
          (v += w.g = c[C + 1]),
          (D += w.b = c[C + 2]),
          (g += R),
          (s += v),
          (u += D),
          (w = w.next),
          (r += t = p.r),
          (o += e = p.g),
          (l += n = p.b),
          (R -= t),
          (v -= e),
          (D -= n),
          (p = p.next),
          (N += 4);
      E += a;
    }
    for (let t = 0; t < a; t++) {
      let e = c[(N = t << 2)],
        n = c[N + 1],
        r = c[N + 2],
        o = x * e,
        g = x * n,
        s = x * r,
        f = b * e,
        E = b * n,
        R = b * r;
      m = h;
      for (let t = 0; t < x; t++) (m.r = e), (m.g = n), (m.b = r), (m = m.next);
      let v = 0,
        D = 0,
        G = 0;
      for (let o = 1, l = a; o <= i; o++)
        (N = (l + t) << 2),
          (f += (m.r = e = c[N]) * (I = x - o)),
          (E += (m.g = n = c[N + 1]) * I),
          (R += (m.b = r = c[N + 2]) * I),
          (v += e),
          (D += n),
          (G += r),
          (m = m.next),
          o < u && (l += a);
      (N = t), (w = h), (p = d);
      for (let i = 0; i < l; i++)
        (c[(C = N << 2)] = (f * y) >> B),
          (c[C + 1] = (E * y) >> B),
          (c[C + 2] = (R * y) >> B),
          (f -= o),
          (E -= g),
          (R -= s),
          (o -= w.r),
          (g -= w.g),
          (s -= w.b),
          (C = (t + ((C = i + x) < u ? C : u) * a) << 2),
          (f += v += w.r = c[C]),
          (E += D += w.g = c[C + 1]),
          (R += G += w.b = c[C + 2]),
          (w = w.next),
          (o += e = p.r),
          (g += n = p.g),
          (s += r = p.b),
          (v -= e),
          (D -= n),
          (G -= r),
          (p = p.next),
          (N += a);
    }
    return n;
  }
  class g {
    constructor() {
      (this.r = 0),
        (this.g = 0),
        (this.b = 0),
        (this.a = 0),
        (this.next = null);
    }
  }
  return {
    image: function (t, e, n, o, l, g) {
      if (
        ("string" == typeof t && (t = document.getElementById(t)),
        !(t && "naturalWidth" in t))
      )
        return;
      const i = l ? "offset" : "natural",
        c = t[i + "Width"],
        s = t[i + "Height"];
      if (
        ("string" == typeof e && (e = document.getElementById(e)),
        !(e && "getContext" in e))
      )
        return;
      g || ((e.style.width = c + "px"), (e.style.height = s + "px")),
        (e.width = c),
        (e.height = s);
      const f = e.getContext("2d");
      f.clearRect(0, 0, c, s),
        f.drawImage(t, 0, 0, t.naturalWidth, t.naturalHeight, 0, 0, c, s),
        isNaN(n) || n < 1 || (o ? r(e, 0, 0, c, s, n) : a(e, 0, 0, c, s, n));
    },
    canvasRGB: a,
    canvasRGBA: r,
    imageDataRGB: l,
    imageDataRGBA: o,
  };
})();
